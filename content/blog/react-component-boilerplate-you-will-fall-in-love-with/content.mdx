---
title: "One immersive React component boilerplate I am eager to share with you"
description: Dont forget to write good description
keywords: sex, drugs, rocknroll
path: "/blog/react-component-boilerplate-you-will-fall-in-love-with-"
date: 2020-12-12
published: false
images:
    - author: Francisco Moreno
      image: ./cover.jpg
      sourceText: Unsplash
      source: https://unsplash.com/@franciscomoreno
      is_cover: 1
      galleryId: 0
---

import { Container } from 'components/Container';

When I build just another web application after the spec made by designers, I create very simple component layouts. The situation drastically changes when building a *design system*, where each component should be reusable and highly sustainable.

So, I have experimented a lot with different ways, and, eventually, I developed the best (as I see it) component layout. Here it is.

## The must have-s

My gear of choice is CSS-in-JS with [Styled-components](https://styled-components.com/) or [Emotion](https://emotion.sh/). It turns quite dull CSS into a fully-featured programming language based on JavaScript. Also please upgrade your React to the one which supports hooks.

## The basics

First and foremost, I start with the component shell itself. I choose a function component over a class component, according to the latest trends and best practices. I also refrain from using default exports everywhere, since named exports make future in-IDE refactoring easier:

~~~typescript jsx
import React, { FC } from 'react';

export const AmazingForm: FC = () => {
    
};
~~~

## The scope of responsibility

Now every component should have a `scope of responsibility`. It other words, a component is only responsible for what is inside of it, and completely unaware of its siblings or a parent node.

Therefore, there is always a *root node* and some optional sub-nodes in case if the component is a complex one:

~~~typescript jsx
import React, { FC } from 'react';
import styled from 'styled-components';

const AmazingFormRoot = styled.div`
`;

const AmazingFormFields = styled.div`
`;

const AmazingFormSubmitButton = styled.button`
`;

export const AmazingForm: FC = () => {
    return (
        <AmazingFormRoot>
            <AmazingFormFields />
            <AmazingFormSubmitButton>
                Submit!
            </AmazingFormSubmitButton>
        </AmazingFormRoot>
    );    
};
~~~

## The component props

I never ever use `interface` to declare prop types.
The reason for that - an interface provokes use of OOP-ish inheritance, which can be a real mess. So instead of stepping onto that ground, I stick to *&laquo;prefer composition over inheritance&raquo;* rule and use `type`.

ðŸ‘‰ I use `***Type` postfix for types to explicitly indicate the fact that this is not a variable.<br />
ðŸ‘‰ All properties of the component should be declared as optional, because the component should gracefully handle situations when it was called without any props.<br />
ðŸ‘‰ A few words regarding naming for the component props. So I have chosen the following agreement:

* name of all callback and event handler props should start with *&laquo;on&raquo;* prefix (e.g. `onSubmitButtonClick`),
* all render props should start with *&laquo;render&raquo;* prefix (e.g. `renderActionBar`),
* all react node containing props should be just nouns (e.g. `actionBar`),
* all feature flag props should start with *&laquo;enable&raquo;* prefix and be set to either `false` or `true` via `defaultProps` (e.g. `enableSubmission`),
* I refrain from the negative declarations (e.g. prefer `enableRendering` by default set to `true` over `disableRendering` set to `false`).

~~~typescript jsx
import React, { FC, MouseEvent } from 'react';
import styled from 'styled-components';

// //////// Types

type AmazingFormPropType = {
    highlighted?: boolean;
    disabled?: boolean;
    onSubmitClick?: (event: MouseEvent<HTMLElement>) => void;
    enableSubmitButton?: boolean;
    // any other props
} & HTMLDivElement; // I prefer composition to say that all native props are also supported

type AmazingFormFieldsPropType = { /* ... */ } & HTMLDivElement;

type AmazingFormSubmitButtonPropType = { /* ... */ } & HTMLButtonElement;

// //////// Styles

const AmazingFormRoot = styled.div<AmazingFormPropType>`
`;

const AmazingFormFields = styled.div<AmazingFormFieldsPropType>`
`;

const AmazingFormSubmitButton = styled.button<AmazingFormSubmitButtonPropType>`
`;

// //////// Component

export const AmazingForm<AmazingFormPropType>: FC = ({
    onSubmitClick,
    enableSubmitButton,
    ...props
}) => {
    return (
        <AmazingFormRoot {...props}>
            <AmazingFormFields />
            {
                enableSubmitButton
                &&
                <AmazingFormSubmitButton onClick={onSubmitClick}>
                    Submit!
                </AmazingFormSubmitButton>
            }
        </AmazingFormRoot>
    );    
};
~~~

## Multiple files

I could not help noticing the listing getting bigger and bigger.

Some of the developers prefer keeping all the accompanying stuff (like style and types declarations) next to the component itself. I tend to disagree with that, because the more complex your component gets, the more code you will have to keep there. And personally I hate files which are more than two screens tall.

So I offer the following file structure:

~~~text
AmazingForm/
    index.ts
    AmazingForm.tsx <-- the component itself goes here
    styles.ts
    types.ts
~~~

The index file `index.ts` is needed to narrow the scope of what I expose to the end user. For instance, if I intend to export only the component itself along with its prop type, my index file will be the following:

~~~typescript
export { AmazingForm } from './AmazingForm';
export type { AmazingFormPropType } from './types';
~~~

## Styling

All the components are being developed in greenhouse conditions. But the thing is, a real project (especially a legacy one) is a much more hostile environment, rather than any Storybook. There may be global CSS that could potentially distort the component appearance.
That is why I create a helper function to reset at least box-sizing, margin, padding and maybe some of the [inherited CSS properties](https://stackoverflow.com/questions/5612302/which-css-properties-are-inherited):

~~~typescript
import { css } from 'styled-components';

export const resetCSS = () => css`
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    // something else
`;
~~~

And apply the function in styles:

~~~typescript
import styled from 'styled-components';
import { AmazingFormPropType, AmazingFormFieldsPropType, AmazingFormSubmitButtonPropType } from './types.ts';
import { resetCSS } from '../../util/resetCSS';

const AmazingFormRoot = styled.div<AmazingFormPropType>`
    ${resetCSS};
    font-size: 1.5rem;
    // ...
`;
const AmazingFormFields = styled.div<AmazingFormFieldsPropType>`
    ${resetCSS};
    font-weight: 500;
    // ...
`;
const AmazingFormSubmitButton = styled.button<AmazingFormSubmitButtonPropType>`
    ${resetCSS};
    color: #f00;
    // ...
`;
~~~

ðŸ‘‰ Props-related CSS. Usually, when it comes to `styled-components`, things become really messy with lots of unreadable figure and square brackets involved. Nevertheless, I have tried to minimize the negative impact by moving everything to a separate helper:

~~~typescript
import styled, { css } from 'styled-components';
import { AmazingFormPropType, AmazingFormFieldsPropType, AmazingFormSubmitButtonPropType } from './types.ts';
import { resetCSS } from '../../util/resetCSS';

const getRootStyle = ({ highlighted, disabled }: AmazingFormPropType) => {
    let result = {};
    
    if (highlighted) {
        result = css`
            ${result};
            border: 1px solid red;
        `;
    }
    
    if (disabled) {
        result = css`
            ${result};
            opacity: 0.5;
            pointer-events: none;
        `;
    }
    
    return result;
};

const AmazingFormRoot = styled.div<AmazingFormPropType>`
    ${resetCSS};
    font-size: 1.5rem;
    // ...
    ${getRootStyle};
`;

// ...
~~~

ðŸ‘‰ When a custom prop falls down to the DOM node, React pollutes the console with a bunch of warnings.
To prevent this, in `styled-components` there is a helper called `shouldForwardProps`.
Unfortunately, the thing gets really bulky since the set of props is blacklisted and no rule of a thumb is applicable here:

~~~typescript
// ...

const rootCustomProps = {
    highlighted: true,
    disabled: true,
};

const AmazingFormRoot = styled.div<AmazingFormPropType>.shouldForwardProps(prop => !(prop in rootCustomProps))`
    ${resetCSS};
    font-size: 1.5rem;
    // ...
    ${getRootStyle};
`;

// ...
~~~

## Visual and logic parts separation

Every components have the UI and &laquo;brains&raquo;. While some of components may have more one than the other, or visa versa, definitely that would be a good idea to decouple it.

So I am gonna put all the logic into a hook called `useAmazingForm` and put into `useAmazingForm.ts` next to the other files.

Doing so I aim to achieve the following:

ðŸ‘‰ the logic is decoupled and separated, the UI stays pretty clean and easily perceivable by just glancing at it,<br />
ðŸ‘‰ I prepare props for each visual node, and feed these props via object spread,<br />
ðŸ‘‰ the hook can be maintained and tested separately.

Please also note that the rest props are always forwarded to the root node.

~~~typescript
import { AmazingFormPropType } from './types.ts';

export const useAmazingForm = ({
   onSubmitClick,
   enableSubmitButton,
   ...props
}: AmazingFormPropType) => {
    // put all your logic here: call some useMemo, useEffect or useCallback, or any other custom hook
    
    return {
        rootProps: props,
        fieldsProps: {  
        },
        submitButtonProps: {
            onClick: onSubmitClick,
        },
        
        enableSubmitButton,
    };
};
~~~

Then I consume the hook in `AmazingForm.tsx`:

~~~typescript jsx
import { AmazingFormRoot, AmazingFormFields, AmazingFormSubmitButton } from './styles.ts'; 
import { AmazingFormPropType } from './types.ts';
import { useAmazingForm } from './useAmazingForm.ts';

export const AmazingForm<AmazingFormPropType>: FC = (props) => {
    
    const {
        rootProps,
        fieldsProps,
        submitButtonProps,
        enableSubmitButton,
    } = useAmazingForm(props);
    
    return (
        <AmazingFormRoot {...rootProps}>
            <AmazingFormFields {...fieldsProps} />
            {
                enableSubmitButton
                &&
                <AmazingFormSubmitButton {...submitButtonProps}>
                    Submit!
                </AmazingFormSubmitButton>
            }
        </AmazingFormRoot>
    );    
};
~~~

## forwardRef

...

## Class names

useAmazingFormClassNames + styling example

## Built-in props

margin, padding, width, height

