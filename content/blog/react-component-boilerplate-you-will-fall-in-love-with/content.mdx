---
title: "One immersive React component boilerplate I am eager to share with you"
description: Dont forget to write good description
keywords: sex, drugs, rocknroll
path: "/blog/react-component-boilerplate-you-will-fall-in-love-with-"
date: 2020-12-12
published: false
images:
    - author: Francisco Moreno
      image: ./cover.jpg
      sourceText: Unsplash
      source: https://unsplash.com/@franciscomoreno
      is_cover: 1
      galleryId: 0
---

import { Container } from 'components/Container';

Front-end engineers create dozens of components with relatively short life cycle every month. But building just another web application is one thing, when it comes to reusable components within a unified and sustainable design system, the situation changes drastically.

While working on a design system, I have experimented a lot, and came up with a quite promising component boilerplate for such occasion. Here it is.

### TL;DR

Codesandbox link here.

A boilerplate generator:

~~~bash
npx @generilla/cli run https://github.com/gannochenko/generators/tree/master/machine
~~~

So,

## Prerequisites

ðŸ‘‰ CSS-in-JS with [Styled-components](https://styled-components.com/) or [Emotion](https://emotion.sh/) for styling. It turns boring CSS into a fully-featured programming language based on JavaScript, so cool.<br />
ðŸ‘‰ React that supports hooks.<br />
ðŸ‘‰ TypeScript.

## First step

I took a boring sign-in as a today's challenge:

![Signup form](./wireframe.png)

The starter code is a function component, according to the latest trends. I also refrain from using default exports everywhere, since named exports make future in-IDE refactoring easier:

~~~typescript jsx
import React, { FC } from 'react';

export const SignInForm: FC = () => {
    
};
~~~

## File structure

Many developers prefer keeping styles and type declarations next to the component itself in the same file. I usually don't do that, because the more complex the component gets, the more code you will have to keep. Several-screens-tall files is not an option for me.

That is why I offer the following file structure:

~~~text
SignInForm/
    index.ts
    SignInForm.tsx <-- the component itself goes here
    styles.ts
    types.ts
~~~

Why is there an `index.ts` file?

First of all, this kind of import will work:<br />`import { SignInForm } from './components/SignInForm'`

Secondly, via `index.ts` file I can explicitly tell which part of the component I wish to expose to the end user, like this:

~~~typescript
export { SignInForm } from './SignInForm';
export type { SignInFormPropType } from './types';
// maybe something else ...
~~~

## The scope of responsibility

Every component has a `scope of responsibility`. It other words, a component is only responsible for what is inside of it, and completely unaware of its siblings or a parent node.

There is always a *root node*:

~~~typescript jsx
...

export const SignInForm: FC<SignInFormPropType> = () => {
    return (
        <SignInFormRoot>
            <SignInInput />
            <SignInInput type="password" />
            <SignInFormSubmitButton>
                Sign-in
            </SignInFormSubmitButton>
        </SignInFormRoot>
    );
};

...
~~~

## Component props

As you may have already noticed, I used `type`, not `interface` when declaring the typings. While interfaces have their advantages in some way,
I prefer going with types. This way the paradigm Â«prefer composition over inheritanceÂ» becomes easily feasible through `union`, unlike the OOP-ish inheritance via `extends` keyword. 

I also

ðŸ‘‰ use `Type` postfix for types to explicitly indicate the fact that this is not a variable,<br />
ðŸ‘‰ have all props optional, because the component should gracefully handle situations when it was called without parameters.<br />

It is also nice to have property naming agreements, for example like these ones:

ðŸ‘‰ names of all callback props should begin with `on` prefix (e.g. `onSubmitButtonClick`),<br />
ðŸ‘‰ if a property is used as a feature flag, its name should begin with `enable` prefix (like `enablePasswordless`),<br />
ðŸ‘‰ names of all render props should start with `render` prefix (e.g. `renderActionBar`)<br />

...and so on.

It may seem too much in the beginning, but when you build a long-lasting design system and wish to remain consistent, not following the rules quickly starts causing problems.

So, the props could be:

~~~typescript jsx
...

// compose custom props with native ones via union
type SignInFormPropType = HTMLFormElement & Partial<{
    loading: boolean;
    onSubmit: ({ login: string; password: string; }) => void;
    enablePasswordless: boolean;
}>;

...
~~~

## Styling

Normally I develop components in greenhouse conditions somewhere in Storybook. But the thing is, real projects (especially legacy ones) provide a much more &laquo;hostile&raquo; environment, since there may be global CSS defined that could potentially distort appearance of the component drastically.

That is why I created a helper function to reset at least box-sizing and margin as well as maybe some of the [inherited CSS properties](https://stackoverflow.com/questions/5612302/which-css-properties-are-inherited):

~~~typescript
import { css } from 'styled-components';

export const resetCSS = () => css`
    box-sizing: border-box;
    margin: 0;
`;
~~~

And apply the function in styles:

~~~typescript
...

const SignInFormRoot = styled.form<SignInFormRootPropType>`
    ${resetCSS};
    padding: 1rem;
`;

const SignInInput = styled.input<SignInInputPropType>`
    ${resetCSS};
    border: 1px solid gray;
    border-radius: 2px;
    // ...
`;

const SignInFormSubmitButton = styled.button<SignInFormSubmitButtonPropType>`
    ${resetCSS};
    border-radius: 2px;
    background-color: blue;
    color: white;
    // ...
`;

...
~~~

## Conditional styles

Usually when it comes to conditional styling with `styled-components`, things turn into unreadable porridge of figure and square brackets very quickly. Nevertheless, I have tried to minimize the negative impact by moving everything to a separate helper:

~~~typescript
...

const getRootStyle = ({ loading, disabled }: SignInFormRootPropType) => {
    let result = {};
    
    if (loading) {
        result = css`
            ${result};
            color: grey;
            // some other css
        `;
    }
    
    if (disabled) {
        result = css`
            ${result};
            display: none;
            // some other css
        `;
    }
    
    // maybe some other props
    
    return result;
};

const SignInFormRoot = styled.form<SignInFormRootPropType>`
    ${resetCSS};
    padding: 1rem;
    ${getRootStyle};
`;

...
~~~

When a custom property goes through a cabbage of wrappers and lands on the DOM node, React starts polluting the console with a bunch of annoying warnings.
To prevent this, `styled-components` starting from v5 has a helper called `shouldForwardProps`.

~~~typescript
// ...

// all unwanted custom props should be blacklisted
const rootCustomProps = {
    loading: true,
    disabled: true,
};

const SignInFormRoot = styled.div<SignInFormRootPropType>.shouldForwardProps(prop => !(prop in rootCustomProps))`
    ${resetCSS};
    padding: 1rem;
    ${getRootStyle};
`;

// ...
~~~

## View and controller separation

Now the cool part comes out!

Back in early days logic and view (UI) of a component were mixed together in a class. Then there was that concept of smart and dumb components.
When hooks came on stage, it became really easy to decouple logic from UI, by creating custom hooks.

So, following this pattern, I am gonna put all the logic into a hook called `useSignInForm` and put into `useSignInForm.ts` next to the other files.
UI stays pretty clean and easily perceivable by just quickly glancing on it.

The result of the hook is a structure that contains props forwarded to the UI elements.

~~~typescript
import { SignInFormPropType } from './types.ts';

export const useSignInForm = ({
   loading,
   onSubmit,
   enablePasswordless,
   ...props
}: SignInFormPropType) => {
    // put all your logic here: call some useMemo, useEffect or useCallback, or any other custom hook
    // ...

    // for example,
    const onSubmitClick = useCallback(() => {
        onSubmit({ login, password }); // take from local state updated by callbacks for inputs
    }, [onSubmit, login, password]);

    return {
        rootProps: props, // the rest props are always forwarded to the root node
        loginInputProps: {
            disabled: loading,
            onChange: onLoginInputChange, // defined somewhere above
        },
        passwordInputProps: {
            type: 'password',
            disabled: loading,
            onChange: onPasswordInputChange, // defined somewhere above
        },
        submitButtonProps: {
            onClick: onSubmitClick,
            disabled: loading,
        },
        showPasswordField: !enablePasswordless,
    };
};
~~~

Then I consume the hook in `SignInForm.tsx`:

~~~typescript jsx
...

import { useSignInForm } from './useSignInForm.ts';

export const SignInForm: FC<SignInFormPropType> = (props) => {

    const {
        rootProps,
        loginInputProps,
        passwordInputProps,
        submitButtonProps,
        showPasswordField
    } = useSignInForm(props);

    return (
        <SignInFormRoot {...rootProps}>
            <SignInInput {...loginInputProps} />
            {
                showPasswordField
                &&
                <SignInInput {...passwordInputProps} />
            }
            <SignInFormSubmitButton {...submitButtonProps}>
                Sign-in
            </SignInFormSubmitButton>
        </SignInFormRoot>
    );
};
~~~

## forwardRef

...

## Class names

useSignInFormClassNames + styling example

## Built-in props

margin, padding, width, height

