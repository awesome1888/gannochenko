---
title: "One immersive React component boilerplate I am eager to share with you"
description: Dont forget to write good description
keywords: sex, drugs, rocknroll
path: "/blog/react-component-boilerplate-you-will-fall-in-love-with-"
date: 2020-12-12
published: false
images:
    - author: Francisco Moreno
      image: ./cover.jpg
      sourceText: Unsplash
      source: https://unsplash.com/@franciscomoreno
      is_cover: 1
      galleryId: 0
---

import { Container } from 'components/Container';

Front-end engineers create dozens of components with relatively short life cycle every month. But building just another web application is one thing, when it comes to reusable components within a unified and sustainable design system, the situation changes drastically.

While working on a design system, I have experimented a lot, and came up with a quite promising component boilerplate for such occasion. Here it is.

TL;DR: codesandbox link here.

## Prerequisites

ðŸ‘‰ CSS-in-JS with [Styled-components](https://styled-components.com/) or [Emotion](https://emotion.sh/) for styling. It turns boring CSS into a fully-featured programming language based on JavaScript.<br />
ðŸ‘‰ React that supports hooks.<br />
ðŸ‘‰ TypeScript.

## First step

I took a boring sign-in as a today's challenge:

![Signup form](./wireframe.png)

The starter code is a function component, according to the latest trends. I also refrain from using default exports everywhere, since named exports make future in-IDE refactoring easier:

~~~typescript jsx
import React, { FC } from 'react';

export const SignInForm: FC = () => {
    
};
~~~

## File structure

Some of the developers prefer keeping things like styles and type declarations next to the component itself in the same file. I usually don't do that, because the more complex the component gets, the more code you will have to keep. Several-screens-tall files is not an option for me.

That is why I offer the following file structure:

~~~text
SignInForm/
    index.ts
    SignInForm.tsx <-- the component itself goes here
    styles.ts
    types.ts
~~~

Why is there an `index.ts` file?

First of all, this kind of import will work:<br />`import { SignInForm } from './components/SignInForm'`

Secondly, via `index.ts` file I can explicitly tell which part of the component I wish to expose to the end user, like this:

~~~typescript
export { SignInForm } from './SignInForm';
export type { SignInFormPropType } from './types';
// maybe something else ...
~~~

## The scope of responsibility

Every component has a `scope of responsibility`. It other words, a component is only responsible for what is inside of it, and completely unaware of its siblings or a parent node.

Therefore, there is always a *root node*:

~~~typescript jsx
...

export const SignInForm: FC<SignInFormPropType> = () => {
    return (
        <SignInFormRoot>
            <SignInInput />
            <SignInInput type="password" />
            <SignInFormSubmitButton>
                Sign-in
            </SignInFormSubmitButton>
        </SignInFormRoot>
    );    
};

...
~~~

## Component props

As you may have already noticed, I used `type`, not `interface` when declaring the typings. While interfaces have their advantages in some way,
I prefer going with types. This way the paradigm Â«prefer composition over inheritanceÂ» becomes easily feasible through `union`, in contrast with OOP-ish inheritance via `extends` keyword. 

I also

ðŸ‘‰ use `Type` postfix for types to explicitly indicate the fact that this is not a variable,<br />
ðŸ‘‰ have all props of the component declared as optional, because the component should gracefully handle situations when it was called without parameters.<br />

It is also nice to have property naming agreements, for example like these ones:

ðŸ‘‰ names of all callback props should begin with `on` prefix (e.g. `onSubmitButtonClick`),<br />
ðŸ‘‰ if a property is used as a feature flag, its name should begin with `enable` prefix (like `enablePasswordless`),<br />
ðŸ‘‰ names of all render props should start with `render` prefix (e.g. `renderActionBar`)<br />

...and so on.

It may seem too much in the beginning, but when you build a long-lasting design system and wish to remain consistent, not following the rules quickly starts causing problems.

So, the form props:

~~~typescript jsx
...

// compose custom props with native ones via union
type SignInFormPropType = HTMLFormElement & Partial<{
    loading: boolean;
    onSubmit: ({ login: string; password: string; }) => void;
    enablePasswordless: boolean;
}>;

...
~~~

## Styling

Normally I develop components in greenhouse conditions somewhere in Storybook. But the thing is, a real project (especially a legacy one) is a much more hostile environment. There may be global CSS defined that could potentially distort the component appearance drastically.

That is why I created a helper function to reset at least box-sizing and margin as well as maybe some of the [inherited CSS properties](https://stackoverflow.com/questions/5612302/which-css-properties-are-inherited):

~~~typescript
import { css } from 'styled-components';

export const resetCSS = () => css`
    box-sizing: border-box;
    margin: 0;
`;
~~~

And apply the function in styles:

~~~typescript
...

const SignInFormRoot = styled.form<SignInFormRootPropType>`
    ${resetCSS};
    padding: 1rem;
`;

const SignInInput = styled.input<SignInInputPropType>`
    ${resetCSS};
    border: 1px solid gray;
    border-radius: 2px;
    // ...
`;

const SignInFormSubmitButton = styled.button<SignInFormSubmitButtonPropType>`
    ${resetCSS};
    border-radius: 2px;
    background-color: blue;
    color: white;
    // ...
`;

...
~~~

## Conditional styles

Usually when it comes to conditional styling with `styled-components`, things turn into unreadable porridge of figure and square brackets very quickly. Nevertheless, I have tried to minimize the negative impact by moving everything to a separate helper:

~~~typescript
...

const getRootStyle = ({ loading, disabled }: SignInFormRootPropType) => {
    let result = {};
    
    if (loading) {
        result = css`
            ${result};
            color: grey;
            // some other css
        `;
    }
    
    if (disabled) {
        result = css`
            ${result};
            display: none;
            // some other css
        `;
    }
    
    // maybe some other props
    
    return result;
};

const SignInFormRoot = styled.form<SignInFormRootPropType>`
    ${resetCSS};
    padding: 1rem;
    ${getRootStyle};
`;

...
~~~

When a custom property goes through the onion of wrappers and lands on the DOM node, React starts polluting the console with a bunch of annoying warnings.
To prevent this, `styled-components` starting from v5 has a helper called `shouldForwardProps`.

~~~typescript
// ...

const rootCustomProps = {
    loading: true,
    disabled: true,
};

const SignInFormRoot = styled.div<SignInFormRootPropType>.shouldForwardProps(prop => !(prop in rootCustomProps))`
    ${resetCSS};
    padding: 1rem;
    ${getRootStyle};
`;

// ...
~~~

## View and controller separation

Every components have the UI and &laquo;brains&raquo;. While some of components may have more one than the other, or visa versa, definitely that would be a good idea to decouple it.

So I am gonna put all the logic into a hook called `useSignInForm` and put into `useSignInForm.ts` next to the other files.

Doing so I aim to achieve the following:

ðŸ‘‰ the logic is decoupled and separated, the UI stays pretty clean and easily perceivable by just glancing at it,<br />
ðŸ‘‰ I prepare props for each visual node, and feed these props via object spread,<br />
ðŸ‘‰ the hook can be maintained and tested separately.

Please also note that the rest props are always forwarded to the root node.

~~~typescript
import { SignInFormPropType } from './types.ts';

export const useSignInForm = ({
   onSubmitClick,
   enableSubmitButton,
   ...props
}: SignInFormPropType) => {
    // put all your logic here: call some useMemo, useEffect or useCallback, or any other custom hook
    
    return {
        rootProps: props,
        fieldsProps: {  
        },
        submitButtonProps: {
            onClick: onSubmitClick,
        },
        
        enableSubmitButton,
    };
};
~~~

Then I consume the hook in `SignInForm.tsx`:

~~~typescript jsx
import { SignInFormRoot, SignInFormFields, SignInFormSubmitButton } from './styles.ts'; 
import { SignInFormPropType } from './types.ts';
import { useSignInForm } from './useSignInForm.ts';

export const SignInForm<SignInFormPropType>: FC = (props) => {
    
    const {
        rootProps,
        fieldsProps,
        submitButtonProps,
        enableSubmitButton,
    } = useSignInForm(props);
    
    return (
        <SignInFormRoot {...rootProps}>
            <SignInFormFields {...fieldsProps} />
            {
                enableSubmitButton
                &&
                <SignInFormSubmitButton {...submitButtonProps}>
                    Submit!
                </SignInFormSubmitButton>
            }
        </SignInFormRoot>
    );    
};
~~~

## forwardRef

...

## Class names

useSignInFormClassNames + styling example

## Built-in props

margin, padding, width, height

