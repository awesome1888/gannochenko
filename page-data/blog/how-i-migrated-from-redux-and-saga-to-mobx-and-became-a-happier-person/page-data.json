{"componentChunkName":"component---src-components-blog-page-layout-blog-page-layout-tsx","path":"/blog/how-i-migrated-from-redux-and-saga-to-mobx-and-became-a-happier-person","result":{"data":{"mdx":{"id":"8c9cc3b1-2f71-5992-9423-4b964921b35c","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How I migrated from Redux and Saga to MobX and became a happier person\",\n  \"description\": \"For quite a while I was using Redux together with Redux Saga and was satisfied. Well, sort of, because I was constantly asking myself \\\"Should the state management always be that complex?\\\" Redux was a great library for it's time, when the concept of a centralized state was not well-coined yet. Nevertheless, one day came, and I have decided it was time to move.\",\n  \"keywords\": \"mobx, redux, saga, react, ui, frontend, state management\",\n  \"path\": \"/blog/how-i-migrated-from-redux-and-saga-to-mobx-and-became-a-happier-person\",\n  \"date\": \"2020-07-15T00:00:00.000Z\",\n  \"published\": true,\n  \"images\": [{\n    \"author\": \"Kin Li\",\n    \"image\": \"./cover.jpg\",\n    \"sourceText\": \"Unsplash\",\n    \"source\": \"https://unsplash.com/@kinli\",\n    \"is_cover\": 1,\n    \"galleryId\": 0\n  }]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For quite a while I was using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux\"), \" together with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux Saga\"), \" and was satisfied. Well, sort of, because I was constantly asking myself \\\"Should the state management always be that complex?\\\"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux\"), \" was a great library for it's time, when the concept of a centralized state was not well-coined yet. Nevertheless, one day came, and I have decided it was time to move.\"), mdx(\"h2\", null, \"Requirements\"), mdx(\"p\", null, \"In my applications I had:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"one special reducer that keeps data of the currently authenticated user, feature flags and some other different stuff,\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"one reducer per page, combined all together with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"combineReducers\"), \",\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"one saga per page,\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a way to observe and affect the state outside of the rendering context,\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a way to keep routing history and state in sync.\")), mdx(\"p\", null, \"So will see how I'll tackle all of this with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MobX\"), \". But first, a short intro to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MobX\"), \" is required.\"), mdx(\"h3\", null, \"The State\"), mdx(\"p\", null, \"According to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MobX\"), \", a state is the heart of an application.\"), mdx(\"p\", null, \"As a substitution for reducers I have decided to make several sub-states. So, there is a \\\"root\\\" state called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"State\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { observable, computed, configure } from 'mobx';\\nimport { Nullable } from '../../type';\\n\\n// pre-configure MobX to have better experience\\n// see https://mobx.js.org/refguide/api.html\\nconfigure({ enforceActions: 'observed', computedRequiresReaction: true });\\n\\nexport class State {\\n    @observable public loading = false;\\n    @observable public error: Nullable<Error> = null;\\n\\n    @computed get ready(): boolean {\\n        return this.loading || !this.error;\\n    }\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MobX\"), \" state is not just a plain object. The state object has a prototype, which automatically enables the ultimate fun with all that OOP stuff: getters / setters, methods, incapsulation and so on. I am not a huge fan of OOP though, but occasionally it may be helpful.\"), mdx(\"p\", null, \"You may have already noticed a couple of decorators back there.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://mobx.js.org/refguide/observable-decorator.html\"\n  }, \"@observable\"), \" decorator tells \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MobX\"), \" to observe this particular property for changes,\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://mobx.js.org/refguide/computed-decorator.html\"\n  }, \"@computed\"), \" decorator tells that there is a getter returning a value that is dependent on some observed properties and does not have side effects. This enables memoization.   \")), mdx(\"h3\", null, \"Consuming the state\"), mdx(\"p\", null, \"First thing first, I need to inject my state into components. React context and hooks are to my rescue here!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React, { useContext } from 'react';\\n\\nimport { State } from './state';\\nimport { Nullable } from '../../type';\\n\\ntype NullableState = Nullable<State>;\\n\\nexport type StatePropsType = {\\n    state: State;\\n};\\n\\nexport const StateContext = React.createContext<NullableState>(null);\\n\\nexport const StateProvider = StateContext.Provider;\\n\\nexport const useGlobalState = () => useContext<NullableState>(StateContext);\\n\")), mdx(\"p\", null, \"Then I modify my \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Providers\"), \" component like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React, { FunctionComponent } from 'react';\\n\\nimport { State } from '../../state/state';\\nimport { StateProvider } from '../../state/context';\\n\\nconst state = new State();\\n\\nexport const Providers: FunctionComponent = ({ children }) => (\\n    <StateProvider value={state}>\\n        {children}\\n    </StateProvider>\\n);\\n\")), mdx(\"p\", null, \"And finally, everywhere I want this state consumed I just use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useGlobalState\"), \" hook:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React, { useEffect, FunctionComponent } from 'react';\\n\\nimport { ApplicationProps } from './type';\\nimport { useGlobalState } from '../state/context';\\n\\nexport const Application: FunctionComponent<ApplicationProps> = () => {\\n    const state = useGlobalState()!;\\n\\n    return (\\n        <div>\\n            MobX is cool!\\n            <Loader state={state} />\\n        </div>\\n    );\\n};\\n\")), mdx(\"h3\", null, \"Reacting to state changes\"), mdx(\"p\", null, \"Having the state consumed does not automatically mean the component will react on it's changes. However, just like Redux has a connector module \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-redux\"), \", there is a module called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mobx-react\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { observer } from 'mobx-react';\\n\\nconst Loader = observer(({ state }: StatePropsType) => <span>{state.ready ? '' : 'Loading...'}</span>);\\n\")), mdx(\"p\", null, \"A few important things here:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://mobx.js.org/refguide/observer-component.html\"\n  }, \"observer\"), \" is a wrapper function that makes our component \\\"sensitive\\\" to state changes. This is an analog of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"connect()\"), \" from 'react-redux'.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There is also an \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://mobx.js.org/refguide/observer-component.html\"\n  }, \"@observer\"), \" decorator, but it works only with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"class components\"), \" (which I use less and less frequently as time goes by).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I shall keep my \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"observers\"), \" as tiny as possible, to avoid re-rendering of different neighboring chunks of UI that do not care about the state at all.\")), mdx(\"h3\", null, \"Changing the state\"), mdx(\"p\", null, \"There are different ways to get the state changed. Personally, I prefer doing it Redux-way: via actions. But actions in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MobX\"), \" is nothing like in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux\"), \": I don't need to dispatch anything anywhere hopefully :) An action here is just a method of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"State\"), \" class.\"), mdx(\"p\", null, \"Let's modify the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"State\"), \" class by adding an action or two!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { observable, computed, configure, action } from 'mobx';\\nimport { Nullable } from '../../type';\\n\\n// pre-configure MobX to have better experience\\n// see https://mobx.js.org/refguide/api.html\\nconfigure({ enforceActions: 'observed', computedRequiresReaction: true });\\n\\nexport class State {\\n    @observable public loading = false;\\n    @observable public error: Nullable<Error> = null;\\n\\n    @computed get ready(): boolean {\\n        return this.loading || !this.error;\\n    }\\n\\n    @action.bound\\n    public start() {\\n        this.error = null;\\n        this.loading = true;\\n    }\\n\\n    @action.bound\\n    public stop(error?: Error) {\\n        if (error) {\\n            this.error = Error;\\n        }\\n        this.loading = false;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Here we have an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://mobx.js.org/refguide/action.html\"\n  }, \"@action.bound\"), \" decorator (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"bound\"), \" means that I can safely use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" inside).\"), mdx(\"p\", null, \"Then nothing stops me from calling these two beautiful actions to change the state:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React, { useEffect, FunctionComponent } from 'react';\\n\\nimport { ApplicationProps } from './type';\\nimport { useGlobalState } from '../state/context';\\n\\nexport const Application: FunctionComponent<ApplicationProps> = () => {\\n    const state = useGlobalState()!;\\n\\n    return (\\n        <div>\\n            MobX is cool!<br />\\n            <button onClick={() => state.start()}>Start</button>{'  '}<button onClick={() => state.stop()}>Start</button><br />\\n            <Loader state={state} />\\n        </div>\\n    );\\n};\\n\")), mdx(\"h3\", null, \"Asynchronous actions\"), mdx(\"p\", null, \"While \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@action.bound\"), \" works nicely for sync actions, for the async ones things turn a bit more complicated.\"), mdx(\"p\", null, \"It might seem so at the beginning, that I just need to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async / await\"), \" to an action, and that will be enough. Well, yeh, technically it solves the case, but what if I need for something more reliable?\\nThe problem with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async / await\"), \" is that I don't really have any control over the flow, and if an action takes longer than anticipated initially to execute, I might get into race condition troubles there.\"), mdx(\"p\", null, \"So consider the following situation: \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A user opens a page. \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The page data starts to load, the user is looking at the loading indicator meanwhile.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The user leaves the page.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It takes some time to load the data due to poor network connection.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The data arrives, the state gets updated even if the displayed page is not the same the data was obtained for.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"???\")), mdx(\"p\", null, \"Is there a way to tell our async action, that we are leaving the page and no longer interested in the data?\"), mdx(\"p\", null, \"Yes.\"), mdx(\"p\", null, \"This is where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"generators\"), \" come out. The coolest thing about a generator yielding promises is that it forms an async process which can be interrupted in the middle, right between two \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yield\"), \" operators. From the developers perspective, a generator looks like just a normal function.\"), mdx(\"p\", null, \"So this is how I have implemented this.\"), mdx(\"h3\", null, \"Sub-states\"), mdx(\"p\", null, \"I have decided to make a sub-state for each page of my application, just like I used to have separate reducers in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux\"), \" before. That is my home page for instance:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import React, { FunctionComponent, useEffect } from 'react';\\n\\nimport { Layout } from '../../components';\\nimport { useGlobalState } from '../../state/context';\\n\\nexport const HomePage: FunctionComponent = () => {\\n    const state = useGlobalState()!;\\n    const { homePage } = state;\\n\\n    useEffect(() => {\\n        homePage.onLoad();\\n\\n        return () => homePage.onUnload();\\n    }, [homePage]);\\n\\n    return (\\n        <Layout>\\n            Honey, I am home!\\n        </Layout>\\n    );\\n};\\n\")), mdx(\"p\", null, \"When I enter or leave the page, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onLoad()\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onUnload()\"), \" is called respectively.\"), mdx(\"p\", null, \"And now the sub-state itself:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { action, observable, flow, isFlowCancellationError } from 'mobx';\\nimport { CancellablePromise } from 'mobx/lib/api/flow';\\nimport { Nullable, ObjectLiteral } from '../../../type';\\n\\nexport class HomePageState {\\n    @observable ready = false;\\n    @observable loading = false;\\n    @observable error: Nullable<Error> = null;\\n\\n    private queryLoad: Nullable<CancellablePromise<unknown>> = null;\\n\\n    onLoad() {\\n        if (this.queryLoad) {\\n            // something is already being loaded for this page. Non-relevant, abort\\n            this.queryLoad.cancel();\\n        }\\n\\n        // start new query\\n        this.queryLoad = this.startLoading();\\n        this.queryLoad.catch((error) => {\\n            if (!isFlowCancellationError(error)) {\\n                // the query was not cancelled, some other error popped up\\n                console.error(error);\\n            }\\n        });\\n    }\\n\\n    onUnload() {\\n        if (this.queryLoad) {\\n            // we are leaving, stop whatever you are doing now\\n            this.queryLoad.cancel();\\n            this.queryLoad = null;\\n        }\\n        this.reset();\\n    }\\n\\n    @action.bound\\n    reset(): void {\\n        this.ready = false;\\n        this.loading = false;\\n        this.error = null;\\n    }\\n\\n    // that is our async process\\n    startLoading = flow(function* startLoading() {\\n        // @ts-ignore who cares?:)\\n        const self = this as HomePageState;\\n\\n        self.loading = true;\\n        self.error = null;\\n        self.ready = false;\\n\\n        // load something really heavy\\n        yield new Promise((resolve) => {\\n            setTimeout(resolve, 5000);\\n        });\\n\\n        yield self.finishLoading();\\n    });\\n\\n    @action.bound\\n    finishLoading(error?: Error): void {\\n        this.loading = false;\\n\\n        if (error) {\\n            this.error = error;\\n        }\\n\\n        this.ready = true;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Okay, so \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://mobx.js.org/best/actions.html\"\n  }, \"flow\"), \" is the cake here. Since it is a generator, it can be cancelled between yields. So cool.\"), mdx(\"p\", null, \"Flow here acts as a direct analog of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Redux Saga\"), \".\"), mdx(\"p\", null, \"I inject a sub-state into the main \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"State\"), \" like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { observable, computed, configure, action } from 'mobx';\\nimport { Nullable } from '../../type';\\nimport { HomePageState } from '../../pages/HomePage';\\n\\n// pre-configure MobX to have better experience\\n// see https://mobx.js.org/refguide/api.html\\nconfigure({ enforceActions: 'observed', computedRequiresReaction: true });\\n\\nexport class State {\\n    @observable public loading = false;\\n    @observable public error: Nullable<Error> = null;\\n\\n    public homePage = new HomePageState();\\n\\n    @computed get ready(): boolean {\\n        return this.loading || !this.error;\\n    }\\n\\n    @action.bound\\n    public start() {\\n        this.error = null;\\n        this.loading = true;\\n    }\\n\\n    @action.bound\\n    public stop(error?: Error) {\\n        if (error) {\\n            this.error = Error;\\n        }\\n        this.loading = false;\\n    }\\n}\\n\")), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"That is basically it! For me the codebase shrank significantly. All the cryptic reducers and the \\\"plain object\\\" state concept is now gone. This all brings me to the following outcome:\"), mdx(\"h3\", null, \"Pros of MobX\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MobX\"), \" is (almost) completely decoupled from the rendering cycle. For me it is a plus, since personally I don't like the do-everything-in-the-component approach. IMO, React should only know how to render the UI, and everything else should be delegated to other parties. Unfortunately, this can also manifest itself as a drawback (see below).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"State\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Reducer\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Action\"), \" entities are now united into one single entity called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"State\"), \". It just feels more natural. I can also treat the entire thing as a blackbox when needed.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All the complexity introduced by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Redux\"), \" is no longer on the picture (Phewww...)\")), mdx(\"h3\", null, \"Cons of MobX\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Decorators work only with class components. If you need to turn a function component into an observer, you need to use alternative \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"observer()\"), \" syntax, which does not please the eye at all.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MobX\"), \" is (almost) completely decoupled from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React\"), \". It means that one day \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MobX\"), \" may become ideologically incompatible with potentially upcoming \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"React\"), \" features.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The state changes are not discrete, and this fact makes the system more difficult to debug.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Therefore, no time travel debugging and undo ability\")), mdx(\"p\", null, \"I have prepared a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/gannochenko/poc_mobx\"\n  }, \"proof of concept repo\"), \" to show the thing in action :)\"), mdx(\"h2\", null, \"Alternatives\"), mdx(\"p\", null, \"If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MobX\"), \" does not suit you well, there is plenty alternatives out there. Just check them out.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.apollographql.com/docs/link/links/state/\"\n  }, \"Apollo link state\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://overmindjs.org/\"\n  }, \"Overmind\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://recoiljs.org/\"\n  }, \"Recoil\"), \" by Facebook\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://reactjs.org/docs/context.html\"\n  }, \"Context API\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/jamiebuilds/unstated-next\"\n  }, \"Unstated-next\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"... and many others :)\")), mdx(\"hr\", null), mdx(\"p\", null, \"I hope it was helpful. So, what do you think of MobX? \", mdx(LinkedInLink, {\n    mdxType: \"LinkedInLink\"\n  }, \"Text me a message to discuss!\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"How I migrated from Redux and Saga to MobX and became a happier person","date":"2020-07-15T00:00:00.000Z","updatedAt":null,"keywords":"mobx, redux, saga, react, ui, frontend, state management","description":"For quite a while I was using Redux together with Redux Saga and was satisfied. Well, sort of, because I was constantly asking myself \"Should the state management always be that complex?\" Redux was a great library for it's time, when the concept of a centralized state was not well-coined yet. Nevertheless, one day came, and I have decided it was time to move.","published":true,"images":[{"image":{"childImageSharp":{"fluid":{"tracedSVG":"data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='400'%20height='265'%20viewBox='0%200%20400%20265'%20preserveAspectRatio='none'%3e%3cpath%20d='M0%203c0%202%200%202%203%202s3%200%201%201C2%206%202%206%203%207c2%201-1%203-2%202L0%2056v47l55-1h55l-3%205-4%207c0%203%200%203-5%203l-8-2-8-2c-37%200-60%201-76%203H0v33h4c10%201%2039%200%2045-1%207-1%208-1%2014%202%2014%207%2024%208%2034%206h11a87%2087%200%200040-8l4-2c0%203%205%206%2010%207l6%201%2017-2a289%20289%200%200194%204l-1%206c0%204-1%205-3%205s-2%201-2%203-1%203-3%203l-9%202c-8%202-8%202-12%200-5-3-7-2-9%204-1%204-3%204-10%203a329%20329%200%2000-43-1c-4%200-9%202-9%203l-2%201-1%201v2c-1%200-1%201%201%201%201%201%201%201-1%203-1%201-1%201%202%203%204%202%2035%203%2043%201h7l7%203c1%200%202%200%201%201l-1%202-2%202c-3%201%202%203%208%203%207%200%2012%201%209%202l-21%203a171%20171%200%2000-31%205%20240%20240%200%2000-20%201%201136%201136%200%2000-87%208%201364%201364%200%2000-87%209H0v30h200a5112%205112%200%2000200-2c1%201%201-4%201-26V0h-90v4a218%20218%200%2001-4%2019%20657%20657%200%2001-10%2036c-3%200-4%201-1%201s3%200%203%202a1081%201081%200%2000-14%2067l-1%204h-30c-23%200-31%200-30-1%201-3-23-3-31%201l-7%202-5%202-6%203a3304%203304%200%2001-21%204c-2%202-2%200%203-7l4-8h9l22-1c13%201%2016%200%2015-2%200-2-2-2-5-2-9%200-11-2-7-5%201-1%202-2%204-1l-1-2-3-3%202-5%201-6h29c2-1%204%202%205%207v4c1%201%201%202-1%203-1%202-3%202-18%202-9%200-10%200-8%201l3%203c-1%202%200%203%202%201h1l13%201c13-1%2022-3%2023-6l2-1%203-1c3-2%200-3-4-2-3%201-3%201-3-1l-1-6-2-1-1-3c0-2%201-2%204-2l5-1c2-2%202-2-2-3h-6l-2-4%202-1c4%200%206-2%204-3-1-2-1-2%202-2l4%201v1c-3%200-2%202%201%203%204%202%209%201%2018-5%204-3%206-3%206%201l-3%205-1%203c1%201-2%202-9%202h-8l10%201h10l1-6c1-9%203-12%206-13%202-1-2-1-19-1-25%200-27%200-25-3%203-5%202-11-2-19l-3-9-1-1v-2l1-3c0-1%200-2%202-3h2v2c2%200%204-6%204-13a69%2069%200%20012-13l1-9%201-6h-78v23l-6-1c-7-2-35-4-33-2v2a1182%201182%200%200126%202l14%201v6h-6a10017%2010017%200%2000-60-4l-13-2-8-1c1%201%201%201-1%201-4%200-3%202%201%202H66l-18-1-3-10v-3c1-2%201-3-2-2l-2-1h-2c-2%200-2%200%200%201%201%201%200%201-3%201l-6-2c-2-3-9-2-9%201h-1l-1-1-2-2h-4c0-2%202-3%204-2h4l3-1c2%201%203%201%203-1s10-3%2018-2c3%201%204%201%204%205%201%205%202%207%203%206s24%201%2030%203l8%202c6%200%207%202%201%202h-5l4%201h25l-4-3-4-2c-1%201-2%200-2-3-1-5-1-6%202-6l3-1-2-1c-1%201-2%200-2-1l-2-1-2-1c0-2-7-2-51-2H0v3m175%20107l-5%207h3c8%201%209%200%209-9%201-7-1-6-7%202'%20fill='%23d3d3d3'%20fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":1.5121951219512195,"src":"/static/229a96448f0e66938b19c9036192150e/77467/cover.jpg","srcSet":"/static/229a96448f0e66938b19c9036192150e/dece2/cover.jpg 310w,\n/static/229a96448f0e66938b19c9036192150e/fcb16/cover.jpg 620w,\n/static/229a96448f0e66938b19c9036192150e/77467/cover.jpg 1240w,\n/static/229a96448f0e66938b19c9036192150e/b1020/cover.jpg 1860w,\n/static/229a96448f0e66938b19c9036192150e/1a900/cover.jpg 1920w","sizes":"(max-width: 1240px) 100vw, 1240px"}}},"author":"Kin Li","source":"https://unsplash.com/@kinli","sourceText":"Unsplash","is_cover":1,"galleryId":0}]}}},"pageContext":{"id":"8c9cc3b1-2f71-5992-9423-4b964921b35c"}},"staticQueryHashes":["1334184578","1334184578","2277278352","2277278352","400101895","400101895"]}